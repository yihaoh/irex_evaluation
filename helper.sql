-- other possibly useful functions:
-- COMPARE_IID(ANYELEMENT, ANYELEMENT) RETURNS BOOLEAN

/*
internal id (IID)
*/

CREATE OR REPLACE FUNCTION GREATER_IID(ANYELEMENT, ANYELEMENT)
RETURNS ANYELEMENT IMMUTABLE LEAKPROOF LANGUAGE SQL AS $$
SELECT
    CASE
        WHEN $1 IS NULL THEN $2 -- needed for the very first transition from NULL initial value
        ELSE (CASE WHEN $1 < $2 THEN $2 ELSE $1 END)
    END
$$;
CREATE OR REPLACE AGGREGATE MAX_IID(ANYELEMENT) (
    SFUNC = GREATER_IID,
    COMBINEFUNC = GREATER_IID,
    STYPE = ANYELEMENT,
    PARALLEL = SAFE
);

CREATE OR REPLACE FUNCTION LESSER_IID(ANYELEMENT, ANYELEMENT)
RETURNS ANYELEMENT IMMUTABLE LEAKPROOF LANGUAGE SQL AS $$
SELECT
    CASE
        WHEN $1 IS NULL THEN $2 -- needed for the very first transition from NULL initial value
        ELSE (CASE WHEN $1 > $2 THEN $2 ELSE $1 END)
    END
$$;
CREATE OR REPLACE AGGREGATE MIN_IID(ANYELEMENT) (
    SFUNC = LESSER_IID,
    COMBINEFUNC = LESSER_IID,
    STYPE = ANYELEMENT,
    PARALLEL = SAFE
);

/*
sargable summaries
*/

CREATE OR REPLACE FUNCTION SARG_SFUNC(ANYARRAY, ANYNONARRAY)
RETURNS ANYARRAY IMMUTABLE LEAKPROOF LANGUAGE SQL AS $$
SELECT ARRAY[LEAST($1[1], $2), GREATEST($1[2], $2)]
$$;

CREATE OR REPLACE FUNCTION SARG_CFUNC(ANYARRAY, ANYARRAY)
RETURNS ANYARRAY IMMUTABLE LEAKPROOF LANGUAGE SQL AS $$
SELECT ARRAY[LEAST($1[1], $2[1]), GREATEST($1[2], $2[2])]
$$;

CREATE OR REPLACE AGGREGATE SARG_AGG(ANYNONARRAY) (
    SFUNC = SARG_SFUNC,
    COMBINEFUNC = SARG_CFUNC,
    STYPE = ANYARRAY,
    INITCOND = '{NULL, NULL}',
    PARALLEL = SAFE
);

CREATE OR REPLACE AGGREGATE SARG_AGG(ANYARRAY) (
    SFUNC = SARG_CFUNC,
    COMBINEFUNC = SARG_CFUNC,
    STYPE = ANYARRAY,
    INITCOND = '{NULL, NULL}',
    PARALLEL = SAFE
);